***错位相减法方便求累计递归的次数，进而求时间复杂度，在堆的问题也能用到***
***计算递归调用的时间复杂度时，金字塔的右下会被忽略很多***

**递归调用的时间复杂度取决于: 递归次数以及每次递归内部的操作次数**
**O(2^N)只有理论意义，计算太慢了**
```
long long Fac(size_t N)
{
    if(N==0 || N==1)
        return 1;

    return Fac(N - 1) * N;
}
```


**时间复杂度O(N*2)**
```
long long Fib(size_t N)
{
    if (N == 1 || N == 2)
        return 1;

    return Fib(N - 1) + Fib(N - 2);
}
```

**时间复杂度O(N) 0-2^63-1**
```
long long Fib(size_t N)
{
    long long f1 = 1;
    long long f2 = 1;
    long long f3 = 0;
    for (int i = 3; i < N; i++)
    {
        f3 = f1 + f2;
        f1 = f2;
        f2 = f3;
    }

    return f3;
}
```


# Leetcode 题目

## 1. 返回倒数第 k 个节点
* **要求**: 只能遍历一遍，复杂度 O(1)
* **思路**: 使用快慢指针，两个指针间隔 k 个位置（错），两个指针相差了 k 个位置

## 2. OR36 链表的回文结构
* **思路**: 找到中间节点，将后半部分反转，然后比较前后两部分是否相等

## 3. 160 相交链表
* **思路 1**: 暴力解，把链表 B 的每个节点和链表 A 的每个节点比较（比较的是地址而非值），时间复杂度 O(N*M) 或者理解为 O(N^2)
* **思路 2**: 两个链表长度不一样，但是相交部分长度一样，所以可以先遍历一遍，得到两个链表的长度，然后长的链表先走差值步，然后两个链表一起走，直到相遇
* **假设法**: 可以避免 if else 语句很冗余的重复代码，先假设 A 链表长，比较完 lenA 和 lenB 后确定谁长谁短，然后再进行操作
